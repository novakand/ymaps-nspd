import * as i0 from '@angular/core';
import { InjectionToken, makeEnvironmentProviders, inject, DOCUMENT, NgZone, PLATFORM_ID, Injectable, EventEmitter, Output, Input, ViewChild, ChangeDetectionStrategy, Component, ContentChild, Directive, TemplateRef, ElementRef } from '@angular/core';
import { Observable, BehaviorSubject, isObservable, of, NEVER, mergeMap, from, tap, fromEvent, throwError, merge, Subject, takeUntil } from 'rxjs';
import { isPlatformBrowser } from '@angular/common';
import { map, switchMap, take, filter } from 'rxjs/operators';

/**
 * @internal
 */
const Y_CONFIG = new InjectionToken('Y_CONFIG', {
    factory: () => ({}),
});
// It must be an arrow function, because compodoc cannot parse functions without issues.
// TODO: convert provideYConfig to a function + create an issue in compodoc about rawdescription.
/**
 * Provides a Y_CONFIG token with the given configuration.
 *
 * ```ts
 * import { provideYConfig, YConfig } from 'angular-yandex-maps-v3';
 *
 * export const config: YConfig = {
 *   apikey: 'X-X-X',
 * };
 *
 * export const appConfig: ApplicationConfig = {
 *   providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideYConfig(config)],
 * };
 * ```
 */
const provideYConfig = (config) => {
    return makeEnvironmentProviders([
        {
            provide: Y_CONFIG,
            useValue: config,
        },
    ]);
};

/**
 * Copied from Taiga UI.
 * https://github.com/taiga-family/taiga-ui/blob/eafb4f498ff57f4a21eebe74aee97a72b5e8d3f8/projects/cdk/observables/zone.ts#L19
 */
function enterZone(zone) {
    return (source) => new Observable((subscriber) => source.subscribe({
        next: (value) => zone.run(() => subscriber.next(value)),
        error: (error) => zone.run(() => subscriber.error(error)),
        complete: () => zone.run(() => subscriber.complete()),
    }));
}
function exitZone(zone) {
    return (source) => new Observable((subscriber) => zone.runOutsideAngular(() => source.subscribe(subscriber)));
}

/**
 * The `YApiLoader` service handles loading of the Yandex.Maps API.
 * Use it if you do not need `YMapComponent`.
 *
 * The service supports dynamic configuration changes by subscribing on a `YConfig` observable.
 * It stores global API objects in a local cache, and updates them in runtime if necessary.
 * That's why do not provide this service, it will break the synchronizations between the local cache and HTML scripts.
 *
 * ```ts
 * import { YApiLoaderService } from 'angular-yandex-maps-v3';
 *
 * @Component()
 * export class AppComponent {
 *   constructor(private yApiLoaderService: YApiLoaderService) {
 *     // Don't forget to unsubscribe
 *     this.yApiLoaderService.load()
 *       .subscribe(v => console.log(v))
 *   }
 * }
 * ```
 */
class YApiLoaderService {
    constructor() {
        this.document = inject(DOCUMENT);
        this.ngZone = inject(NgZone);
        this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
        this.defaultConfig = {
            lang: 'ru_RU',
        };
        this.config$ = new BehaviorSubject(this.defaultConfig);
        this.cache = new Map();
        let config = inject(Y_CONFIG);
        if (!isObservable(config)) {
            config = of(config);
        }
        config.subscribe((config) => {
            this.config$.next({
                ...this.defaultConfig,
                ...config,
            });
        });
    }
    /**
     * Loads the Yandex.Maps API.
     * Runs outside an Angular zone.
     */
    load() {
        if (!this.isBrowser) {
            return NEVER;
        }
        return this.config$.pipe(
        // 3rd party libraries shouldn't be run in a zone.
        // Libraries run tons of different events (requestAnimationFrame, setTimeout, etc.).
        // We do not need to run change detection for these events from the library.
        // Exit from a zone here, so all components are also created outside a zone.
        exitZone(this.ngZone), mergeMap((config) => {
            // We use a script source as a cache key, since there are a lot of parameters that affect the API.
            // We can't rely only on one parameter. E.g., a key is changed, we need to reload the API.
            const cacheKey = this.getScriptSource(config);
            const cache = this.cache.get(cacheKey) || {};
            // If it exists in the cache, return the ymaps3 from it,
            // since script.onload triggers only once.
            if (cache.ymaps3) {
                const apiObject = cache.ymaps3;
                // ready confirms that the API and DOM are ready for use,
                // we can return of(window.ymaps3), but calling ready is safer, I believe.
                return from(apiObject.ready).pipe(
                // Each nested operator should run outside the zone.
                // Refer to the comment above for the reason why we need to exit the zone.
                exitZone(this.ngZone), 
                // Actually, we need to update it only if they are not equal,
                // it happens if we change the configuration which required new window.ymaps3.
                tap(() => (window.ymaps3 = apiObject)), map(() => apiObject));
            }
            let script = cache.script;
            // It's possible that we have a script, but do not have ymaps3.
            // It happens if there are concurrent requests, and the first request creates the script,
            // while the second must just wait for the API to be loaded.
            if (!script) {
                script = this.createScript(config);
                this.cache.set(cacheKey, { script });
                this.document.body.appendChild(script);
            }
            if (window.ymaps3) {
                // The API throws an error on script load if window.ymaps3 exists.
                // So, before changing the configuration, delete the global object.
                delete window.ymaps3;
                // On the first API load, we import packages that are stored in chunks.
                // When we load a new API configuration, it checks this global variable
                // and tries to execute them. The problem is that window.ymaps3 is already deleted,
                // and this script hasn't loaded a new ymaps3 yet. As a result, we get an error
                // from these packages. That's why we need to delete these chunks, so there is no
                // difference between the 1st and nth script load.
                delete window.__chunk_yandex_ymaps3;
            }
            // window.ymaps3 is set explicitly via a script load event.
            const load = fromEvent(script, 'load').pipe(switchMap(() => from(ymaps3.ready)), tap(() => this.cache.set(cacheKey, { script, ymaps3 })), map(() => ymaps3));
            const error = fromEvent(script, 'error').pipe(switchMap(throwError));
            return merge(load, error).pipe(
            // Each nested operator should run outside the zone.
            // Refer to the comment above for the reason why we need to exit the zone.
            exitZone(this.ngZone), take(1));
        }));
    }
    createScript(config) {
        const script = this.document.createElement('script');
        script.type = 'text/javascript';
        script.src = this.getScriptSource(config);
        script.id = 'yandexMapsApiScript';
        script.async = true;
        script.defer = true;
        return script;
    }
    /**
     * Returns a script source from a config.
     * @param config parameters to add to a source
     * @example
     * // returns 'https://api-maps.yandex.ru/2.1/?apikey=658f67a2-fd77-42e9-b99e-2bd48c4ccad4&lang=en_US'
     * getScriptSource({ apikey: '658f67a2-fd77-42e9-b99e-2bd48c4ccad4', lang: 'en_US' })
     */
    getScriptSource(config) {
        const params = this.convertConfigIntoQueryParams(config);
        return `https://api-maps.yandex.ru/v3/?${params}`;
    }
    /**
     * Converts a config into query string parameters.
     * @param config object to convert
     * @example
     * // returns "lang=ru_RU&apikey=XXX"
     * convertIntoQueryParams({ lang: 'ru_RU', apikey: 'XXX' })
     */
    convertConfigIntoQueryParams(config) {
        return Object.entries(config)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YApiLoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YApiLoaderService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YApiLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

/**
 * Generates a random string based on Date in hexadecimal numeral system.
 * @example f175517fa4f3
 * @internal
 */
const generateRandomId = () => `f${Date.now().toString(16)}`;

/**
 * This component wraps the [ymaps3.YMap](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymap) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 10,
 *     },
 *     theme: 'dark',
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 * </y-map>
 * ```
 */
class YMapComponent {
    constructor() {
        this.yaApiLoaderService = inject(YApiLoaderService);
        this.ngZone = inject(NgZone);
        this.destroy$ = new Subject();
        this.map$ = new BehaviorSubject(null);
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngAfterViewInit() {
        this.yaApiLoaderService
            .load()
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => {
            const id = generateRandomId();
            const map = this.createMap(id);
            /**
             * Once the configuration is changed, e.g. language,
             * we need to reinitialize the map.
             */
            if (this.map$.value) {
                this.map$.value.destroy();
            }
            this.map$.next(map);
            this.ready.emit({ ymaps3, entity: map });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.map$.value) {
                this.map$.value.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        this.map$.value?.destroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    createMap(containerId) {
        const containerElem = this.container.nativeElement;
        containerElem.setAttribute('id', containerId);
        containerElem.style.cssText = 'width: 100%; height: 100%;';
        // The API mutates the configuration.
        // It changes `props.config`, which causes errors on language change.
        // Since we need to pass a clean state each time, pass a copy.
        const clonedProps = { ...this.props };
        return new ymaps3.YMap(containerElem, clonedProps, this.children);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "21.0.6", type: YMapComponent, isStandalone: true, selector: "y-map", inputs: { props: "props", children: "children" }, outputs: { ready: "ready" }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true }], usesOnChanges: true, ngImport: i0, template: '<div #container></div>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'y-map',
                    template: '<div #container></div>',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { container: [{
                type: ViewChild,
                args: ['container']
            }], props: [{
                type: Input,
                args: [{ required: true }]
            }], children: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapClusterer](https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/clusterer/#class-ymapclusterer) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 * This component is from the `@yandex/ymaps3-clusterer@0.0.1` package, which is asynchronously loaded when you use this component.
 *
 * The Yandex.Maps class is quite challenging, so I recommend checking the official documentation.
 * The component encapsulates some logic, making the class easier to use.
 * It remains fully customizable, and you can replicate the entire code from the official example.
 *
 * The Yandex.Maps class accepts `cluster` and `marker` callbacks that should return HTML for the elements.
 * You can achieve the same behavior using this component in two ways:
 *
 * 1. Pass cluster and marker to props and write completely custom logic. This is the same process that the library handles internally.
 * 2. Use `<ng-template #cluster let-context>` and `<ng-template #marker let-context>`, where the HTML from the templates is passed to `YMapMarker`.
 *
 * When using templates, you can access arguments from the callback through the `$implicit` variable.
 *
 * To define markers, you do not need to create the markers themselves; instead, you need to pass a `Feature[]`.
 * The official example creates an array of coordinates and maps it to the features array.
 *
 * The clustering method is `clusterByGrid({ gridSize: 64 })` by default, but you can override it and other options by passing them to `props`.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 10,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *   <y-map-default-features-layer />
 *
 *   <!-- Define your coordinates in the component and map them to Feature[] -->
 *   <y-map-clusterer
 *     [props]="{
 *       features: [
 *         {
 *           type: 'Feature',
 *           id: '0',
 *           geometry: {
 *             type: 'Point',
 *             coordinates: [-0.597696, 51.907351],
 *           },
 *         },
 *       ],
 *     }"
 *   >
 *     <ng-template #marker let-context>
 *       <!-- Your custom HTML for a point/marker -->
 *       <img src="./pin.svg" />
 *     </ng-template>
 *
 *     <ng-template #cluster let-context>
 *       <!-- Your custom HTML for a clusterer point/marker -->
 *       {{ context.features.length }}
 *     </ng-template>
 *   </y-map-clusterer>
 * </y-map>
 * ```
 */
class YMapClustererDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngAfterContentInit() {
        this.yMapComponent.map$
            .pipe(filter(Boolean), switchMap((map) => 
        // It's safe to call it each time, the Yandex.Maps API handles multiple requests under the hood.
        from(ymaps3.import('@yandex/ymaps3-clusterer@0.0.1')).pipe(tap(({ YMapClusterer, clusterByGrid }) => {
            const marker = (feature) => {
                const element = this.getTemplateElement(this.markerTemplate, feature);
                return new ymaps3.YMapMarker({
                    coordinates: feature.geometry.coordinates,
                }, element);
            };
            const cluster = (coordinates, features) => {
                const element = this.getTemplateElement(this.clusterTemplate, {
                    coordinates,
                    features,
                });
                return new ymaps3.YMapMarker({
                    coordinates,
                }, element);
            };
            this.clusterer = new YMapClusterer({
                marker,
                cluster,
                method: clusterByGrid({ gridSize: 64 }),
                ...this.props,
            });
            map.addChild(this.clusterer);
            this.ready.emit({ ymaps3, entity: this.clusterer });
        }))), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.clusterer) {
                this.clusterer.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.clusterer) {
            this.yMapComponent.map$.value?.removeChild(this.clusterer);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    getTemplateElement(templateRef, context) {
        if (!templateRef) {
            throw new Error('TemplateRef cannot be undefined. It must be projected to the component.');
        }
        const view = templateRef.createEmbeddedView({ $implicit: context });
        view.detectChanges();
        // Get the first node, which is inside <ng-template />
        const element = view.rootNodes[0];
        if (!element) {
            throw new Error('TemplateRef cannot be empty. It must contain a node.');
        }
        return element;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapClustererDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapClustererDirective, isStandalone: true, selector: "y-map-clusterer", inputs: { props: "props" }, outputs: { ready: "ready" }, queries: [{ propertyName: "markerTemplate", first: true, predicate: ["marker"], descendants: true }, { propertyName: "clusterTemplate", first: true, predicate: ["cluster"], descendants: true }], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapClustererDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-clusterer',
                }]
        }], propDecorators: { markerTemplate: [{
                type: ContentChild,
                args: ['marker']
            }], clusterTemplate: [{
                type: ContentChild,
                args: ['cluster']
            }], props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapDefaultMarker](https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/markers/#class-ymapdefaultmarker) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 * This component is from the `@yandex/ymaps3-markers@0.0.1` package, which is asynchronously loaded when you use this component.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 10,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *   <y-map-default-features-layer />
 *
 *   <y-map-default-marker
 *     [props]="{
 *       coordinates: [-0.127696, 51.507351],
 *       title: 'Hello World!',
 *       subtitle: 'kind and bright',
 *       color: 'blue',
 *     }"
 *   />
 * </y-map>
 * ```
 */
class YMapDefaultMarkerDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$
            .pipe(filter(Boolean), switchMap((map) => 
        // It's safe to call it each time, the Yandex.Maps API handles multiple requests under the hood.
        from(ymaps3.import('@yandex/ymaps3-markers@0.0.1')).pipe(tap(({ YMapDefaultMarker }) => {
            this.marker = new YMapDefaultMarker(this.props);
            map.addChild(this.marker);
            this.ready.emit({ ymaps3, entity: this.marker });
        }))), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.marker) {
                this.marker.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.marker) {
            this.yMapComponent.map$.value?.removeChild(this.marker);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapDefaultMarkerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapDefaultMarkerDirective, isStandalone: true, selector: "y-map-default-marker", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapDefaultMarkerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-default-marker',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapFeature](https://yandex.ru/dev/jsapi30/doc/en/ref/#class-ymapfeature) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *   <y-map-default-features-layer />
 *
 *   <y-map-feature
 *     [props]="{
 *       geometry: {
 *         type: 'Polygon',
 *         coordinates: [
 *           [
 *             [-0.557696, 51.727351],
 *             [0.302304, 51.727351],
 *             [0.302304, 51.237351],
 *             [-0.557696, 51.237351],
 *           ],
 *         ],
 *       },
 *       style: {
 *         stroke: [{ color: '#006efc', width: 4, dash: [5, 10] }],
 *         fill: 'rgba(56, 56, 219, 0.5)',
 *       },
 *     }"
 *   />
 * </y-map>
 * ```
 */
class YMapFeatureDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            this.feature = new ymaps3.YMapFeature(this.props);
            map.addChild(this.feature);
            this.ready.emit({ ymaps3, entity: this.feature });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.feature) {
                this.feature.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.feature) {
            this.yMapComponent.map$.value?.removeChild(this.feature);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapFeatureDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapFeatureDirective, isStandalone: true, selector: "y-map-feature", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapFeatureDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-feature',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapFeatureDataSource](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapfeaturedatasource) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-feature-data-source [props]="{ id: 'clusterer-source' }" />
 * </y-map>
 * ```
 */
class YMapFeatureDataSourceDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            this.source = new ymaps3.YMapFeatureDataSource(this.props);
            map.addChild(this.source);
            this.ready.emit({ ymaps3, entity: this.source });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.source) {
                this.source.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.source) {
            this.yMapComponent.map$.value?.removeChild(this.source);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapFeatureDataSourceDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapFeatureDataSourceDirective, isStandalone: true, selector: "y-map-feature-data-source", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapFeatureDataSourceDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-feature-data-source',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapHint](https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/hint/#class-ymaphint) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 * This component is from the `@yandex/ymaps3-hint@0.0.1` package, which is asynchronously loaded when you use this component.
 *
 * The API of this component is complicated, but it's very close to what the official React wrapper suggests.
 * We strongly recommend reading and understanding the [official React example](https://yandex.ru/dev/jsapi30/doc/ru/examples/cases/hints) for this component.
 *
 * In a nutshell, each entity (YMapFeature, YMapMarker, YMapHotspot) has a `properties` property, which is `Record<string, unknown>`.
 * When you define these components, you can pass any metadata to this property, which you can later access using `YMapHintProps['hint']`.
 * When you pass a callback to `YMapHintProps['hint']`, you can read the `properties` property and return the hint based on the metadata.
 * What you return from `YMapHintProps['hint']` will be available in `<ng-template />` (it's set via $implicit, so you can use any name for let-*).
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *   <y-map-default-features-layer />
 *
 *   <!-- onHint = (object?: YMapFeature | YMapMarker | YMapHotspot) => object?.properties?.['anyNameKey']; -->
 *   <!-- It accepts an entity on which a user hovered and returns a context, which is set to $implicit in ng-template. -->
 *   <!-- Your function can return anything since we have access to the returned value. -->
 *   <y-map-hint [props]="{ hint: onHint }">
 *     <ng-template let-context>
 *       <div
 *         style="
 *           background-color: #fff;
 *           border-radius: 6px;
 *           padding: 3px 6px 4px;
 *           margin-left: 15px;
 *         "
 *       >
 *         <!-- context.hint is the return value of onHint -->
 *         {{ context?.hint }}
 *       </div>
 *     </ng-template>
 *   </y-map-hint>
 *
 *   <y-map-default-marker
 *     [props]="{
 *       coordinates: [-0.127696, 51.507351],
 *       properties: {
 *         anyNameKey: 'Central London',
 *       },
 *     }"
 *   />
 * </y-map>
 * ```
 */
class YMapHintDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngAfterContentInit() {
        this.yMapComponent.map$
            .pipe(filter(Boolean), switchMap((map) => 
        // It's safe to call it each time, the Yandex.Maps API handles multiple requests under the hood.
        from(ymaps3.import('@yandex/ymaps3-hint@0.0.1')).pipe(tap(({ YMapHint, YMapHintContext }) => {
            if (!this.template) {
                throw new Error('TemplateRef cannot be undefined. It must be projected to the component.');
            }
            this.hint = new YMapHint(this.props);
            this.hint.addChild(this.createHintContainer(this.template, YMapHintContext));
            map.addChild(this.hint);
            this.ready.emit({ ymaps3, entity: this.hint });
        }))), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.hint) {
                this.hint.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.hint) {
            this.yMapComponent.map$.value?.removeChild(this.hint);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * To render a hint, a container is required.
     * This method isolates all the container creation logic and returns the entity.
     */
    createHintContainer(templateRef, _YMapHintContext) {
        // The main logic is taken from the official documentation.
        // See https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/hint/#class-ymaphint
        class HintContainer extends ymaps3.YMapGroupEntity {
            _onAttach() {
                // Create a view with an empty context to get a basic HTML layout.
                const view = templateRef.createEmbeddedView({ $implicit: null });
                view.detectChanges();
                // Get the first node, which is inside <ng-template />
                this._element = view.rootNodes[0];
                if (!this._element) {
                    throw new Error('TemplateRef cannot be empty. It must contain a node.');
                }
                this._detachDom = ymaps3.useDomContext(this, this._element, null);
                this._watchContext(_YMapHintContext, () => {
                    // Provide the hint context to the <ng-template /> component.
                    // This context can be either null, or { hint: any }.
                    // The value inside the context depends on YMapHintProps['hint'] value.
                    view.context.$implicit = this._consumeContext(_YMapHintContext);
                    view.detectChanges();
                }, { immediate: true });
            }
            _onDetach() {
                if (this._detachDom) {
                    this._detachDom();
                }
                this._detachDom = undefined;
            }
        }
        return new HintContainer({});
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapHintDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapHintDirective, isStandalone: true, selector: "y-map-hint", inputs: { props: "props" }, outputs: { ready: "ready" }, queries: [{ propertyName: "template", first: true, predicate: TemplateRef, descendants: true }], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapHintDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-hint',
                }]
        }], propDecorators: { template: [{
                type: ContentChild,
                args: [TemplateRef]
            }], props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapListener](https://yandex.ru/dev/jsapi30/doc/en/ref/#class-ymaplistener) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-listener
 *     [props]="{
 *       onClick: onClick,
 *     }"
 *   />
 * </y-map>
 * ```
 */
class YMapListenerDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            this.listener = new ymaps3.YMapListener(this.props);
            map.addChild(this.listener);
            this.ready.emit({ ymaps3, entity: this.listener });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.listener) {
                this.listener.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.listener) {
            this.yMapComponent.map$.value?.removeChild(this.listener);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapListenerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapListenerDirective, isStandalone: true, selector: "y-map-listener", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapListenerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-listener',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapMarker](https://yandex.ru/dev/jsapi30/doc/en/ref/#class-ymapmarker) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. `YMapMarker['element']` can only be projected, see the example below.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *   <y-map-default-features-layer />
 *
 *   <y-map-marker
 *     [props]="{
 *       coordinates: [-0.127696, 51.507351],
 *       draggable: true,
 *     }"
 *   >
 *     <img
 *       width="64"
 *       height="64"
 *       style="border-radius: 50%"
 *       src="https://cdn.openart.ai/published/nI5hC8sFzqKnKbJtW1hA/ExVfxYNJ_E0Yh_256.webp"
 *       alt="Bulldog"
 *     />
 *   </y-map-marker>
 * </y-map>
 * ```
 */
class YMapMarkerDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.elementRef = inject(ElementRef);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.marker) {
                this.marker.update(changes['props'].currentValue);
            }
        });
    }
    ngAfterViewInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            // ContentChild cannot be used without a selector.
            // We do not have any selectors, and we do not want to force users to use them.
            // All we need is an alternative to React children, just to get everything projected to the component.
            // Using an element reference is probably the easiest solution for this.
            if (!this.element) {
                // It must be saved because the Yandex.Maps API deletes the element from the DOM.
                // Therefore, after a configuration change, we pass null, since it's deleted.
                this.element = this.elementRef.nativeElement.firstChild;
            }
            this.marker = new ymaps3.YMapMarker(this.props, this.element);
            map.addChild(this.marker);
            this.ready.emit({ ymaps3, entity: this.marker });
        });
    }
    ngOnDestroy() {
        if (this.marker) {
            this.yMapComponent.map$.value?.removeChild(this.marker);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapMarkerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapMarkerDirective, isStandalone: true, selector: "y-map-marker", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapMarkerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-marker',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapControls](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapcontrols) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     ...
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapControlsDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        this.controls$ = new BehaviorSubject(null);
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            const controls = new ymaps3.YMapControls(this.props, this.children);
            map.addChild(controls);
            this.controls$.next(controls);
            this.ready.emit({ ymaps3, entity: controls });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.controls$.value) {
                this.controls$.value.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.controls$.value) {
            this.yMapComponent.map$.value?.removeChild(this.controls$.value);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlsDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapControlsDirective, isStandalone: true, selector: "y-map-controls", inputs: { props: "props", children: "children" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-controls',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], children: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapControl](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapcontrol) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. This component must be used inside a `y-map-controls` component.
 * Custom HTML can only be projected, see the example below.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     <y-map-control>
 *       <p>Custom HTML</p>
 *     </y-map-control>
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapControlDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.elementRef = inject(ElementRef);
        this.yMapControlsDirective = inject(YMapControlsDirective);
        this.destroy$ = new Subject();
        /**
         * See the API entity documentation for detailed information. Supports ngOnChanges.
         * {@link https://yandex.ru/dev/jsapi30/doc/ru/ref/#YMapControlProps}
         */
        this.props = {};
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngAfterViewInit() {
        this.yMapControlsDirective.controls$
            .pipe(filter(Boolean), takeUntil(this.destroy$))
            .subscribe((controls) => {
            // ContentChild cannot be used without a selector.
            // We do not have any selectors, and we do not want to force users to use them.
            // All we need is an alternative to React children, just to get everything projected to the component.
            // Using an element reference is probably the easiest solution for this.
            if (!this.element) {
                // It must be saved because the Yandex.Maps API deletes the element from the DOM.
                // Therefore, after a configuration change, we pass null, since it's deleted.
                this.element = this.elementRef.nativeElement.firstChild;
            }
            this.control = new ymaps3.YMapControl(this.props);
            this.control.addChild(this.createControlContainer(this.element));
            controls.addChild(this.control);
            this.ready.emit({ ymaps3, entity: this.control });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.control) {
                this.control.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.control) {
            this.yMapControlsDirective.controls$.value?.removeChild(this.control);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * To render a control, a container is required.
     * This method isolates all the container creation logic and returns the entity.
     */
    createControlContainer(element) {
        // This logic is taken from the official documentation.
        // See https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/hint/#class-ymaphint
        class ControlContainer extends ymaps3.YMapGroupEntity {
            _onAttach() {
                this._element = element;
                this._detachDom = ymaps3.useDomContext(this, this._element, null);
            }
            _onDetach() {
                if (this._detachDom) {
                    this._detachDom();
                }
                this._detachDom = undefined;
            }
        }
        return new ControlContainer({});
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapControlDirective, isStandalone: true, selector: "y-map-control", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-control',
                }]
        }], propDecorators: { props: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapControlButton](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapcontrolbutton) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. This component must be used inside a `y-map-controls` component.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     <y-map-control-button [props]="{ text: 'Hello' }" />
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapControlButtonDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapControlsDirective = inject(YMapControlsDirective);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapControlsDirective.controls$
            .pipe(filter(Boolean), takeUntil(this.destroy$))
            .subscribe((controls) => {
            this.control = new ymaps3.YMapControlButton(this.props, this.options);
            controls.addChild(this.control);
            this.ready.emit({ ymaps3, entity: this.control });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.control) {
                this.control.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.control) {
            this.yMapControlsDirective.controls$.value?.removeChild(this.control);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapControlButtonDirective, isStandalone: true, selector: "y-map-control-button", inputs: { props: "props", options: "options" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-control-button',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], options: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapControlCommonButton](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapcontrolcommonbutton) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. This component must be used inside a `y-map-controls` component.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     <y-map-control-common-button [props]="{ text: 'Hello' }" />
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapControlCommonButtonDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapControlsDirective = inject(YMapControlsDirective);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapControlsDirective.controls$
            .pipe(filter(Boolean), takeUntil(this.destroy$))
            .subscribe((controls) => {
            this.control = new ymaps3.YMapControlCommonButton(this.props, this.options);
            controls.addChild(this.control);
            this.ready.emit({ ymaps3, entity: this.control });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.control) {
                this.control.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.control) {
            this.yMapControlsDirective.controls$.value?.removeChild(this.control);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlCommonButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapControlCommonButtonDirective, isStandalone: true, selector: "y-map-control-common-button", inputs: { props: "props", options: "options" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapControlCommonButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-control-common-button',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], options: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapGeolocationControl](https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/controls/#class-ymapgeolocationcontrol) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. This component must be used inside a `y-map-controls` component.
 * This component is from the `@yandex/ymaps3-controls@0.0.1` package, which is asynchronously loaded when you use this component.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     <y-map-geolocation-control />
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapGeolocationControlDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapControlsDirective = inject(YMapControlsDirective);
        this.destroy$ = new Subject();
        /**
         * See the API entity documentation for detailed information. Supports ngOnChanges.
         * {@link https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/controls/#YMapGeolocationControlProps}
         */
        this.props = {};
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapControlsDirective.controls$
            .pipe(filter(Boolean), switchMap((controls) => 
        // It's safe to call it each time, the Yandex.Maps API handles multiple requests under the hood.
        from(ymaps3.import('@yandex/ymaps3-controls@0.0.1')).pipe(tap(({ YMapGeolocationControl }) => {
            this.control = new YMapGeolocationControl(this.props);
            controls.addChild(this.control);
            this.ready.emit({ ymaps3, entity: this.control });
        }))), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.control) {
                this.control.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.control) {
            this.yMapControlsDirective.controls$.value?.removeChild(this.control);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapGeolocationControlDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapGeolocationControlDirective, isStandalone: true, selector: "y-map-geolocation-control", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapGeolocationControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-geolocation-control',
                }]
        }], propDecorators: { props: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapOpenMapsButton](https://yandex.ru/dev/jsapi30/doc/ru/ref/modules/controls-extra/#class-ymapopenmapsbutton) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. This component must be used inside a `y-map-controls` component.
 * This component is from the `@yandex/ymaps3-controls-extra` module, which is asynchronously loaded when you use this component.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     <y-map-open-maps-button />
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapOpenMapsButtonDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapControlsDirective = inject(YMapControlsDirective);
        this.destroy$ = new Subject();
        /**
         * See the API entity documentation for detailed information. Supports ngOnChanges.
         * {@link https://yandex.ru/dev/jsapi30/doc/ru/ref/modules/controls-extra/#YMapOpenMapsButtonProps}
         */
        this.props = {};
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapControlsDirective.controls$
            .pipe(filter(Boolean), switchMap((controls) => 
        // It's safe to call it each time, the Yandex.Maps API handles multiple requests under the hood.
        from(ymaps3.import('@yandex/ymaps3-controls-extra')).pipe(tap(({ YMapOpenMapsButton }) => {
            this.control = new YMapOpenMapsButton(this.props);
            controls.addChild(this.control);
            this.ready.emit({ ymaps3, entity: this.control });
        }))), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.control) {
                this.control.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.control) {
            this.yMapControlsDirective.controls$.value?.removeChild(this.control);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapOpenMapsButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapOpenMapsButtonDirective, isStandalone: true, selector: "y-map-open-maps-button", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapOpenMapsButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-open-maps-button',
                }]
        }], propDecorators: { props: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapScaleControl](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapscalecontrol) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. This component must be used inside a `y-map-controls` component.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     <y-map-scale-control />
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapScaleControlDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapControlsDirective = inject(YMapControlsDirective);
        this.destroy$ = new Subject();
        /**
         * See the API entity documentation for detailed information. Supports ngOnChanges.
         * {@link https://yandex.ru/dev/jsapi30/doc/ru/ref/#YMapScaleControlProps}
         */
        this.props = {};
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapControlsDirective.controls$
            .pipe(filter(Boolean), takeUntil(this.destroy$))
            .subscribe((controls) => {
            this.control = new ymaps3.YMapScaleControl(this.props);
            controls.addChild(this.control);
            this.ready.emit({ ymaps3, entity: this.control });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.control) {
                this.control.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.control) {
            this.yMapControlsDirective.controls$.value?.removeChild(this.control);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapScaleControlDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapScaleControlDirective, isStandalone: true, selector: "y-map-scale-control", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapScaleControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-scale-control',
                }]
        }], propDecorators: { props: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapZoomControl](https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/controls/#class-ymapzoomcontrol) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments. This component must be used inside a `y-map-controls` component.
 * This component is from the `@yandex/ymaps3-controls@0.0.1` package, which is asynchronously loaded when you use this component.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 9,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-controls [props]="{ position: 'top' }">
 *     <y-map-zoom-control-button />
 *   </y-map-controls>
 * </y-map>
 * ```
 */
class YMapZoomControlDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapControlsDirective = inject(YMapControlsDirective);
        this.destroy$ = new Subject();
        /**
         * See the API entity documentation for detailed information. Supports ngOnChanges.
         * {@link https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/controls/#YMapZoomControlProps}
         */
        this.props = {};
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapControlsDirective.controls$
            .pipe(filter(Boolean), switchMap((controls) => 
        // It's safe to call it each time, the Yandex.Maps API handles multiple requests under the hood.
        from(ymaps3.import('@yandex/ymaps3-controls@0.0.1')).pipe(tap(({ YMapZoomControl }) => {
            this.control = new YMapZoomControl(this.props, this.options);
            controls.addChild(this.control);
            this.ready.emit({ ymaps3, entity: this.control });
        }))), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.control) {
                this.control.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.control) {
            this.yMapControlsDirective.controls$.value?.removeChild(this.control);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapZoomControlDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapZoomControlDirective, isStandalone: true, selector: "y-map-zoom-control-button", inputs: { props: "props", options: "options" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapZoomControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-zoom-control-button',
                }]
        }], propDecorators: { props: [{
                type: Input
            }], options: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapDefaultFeaturesLayer](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapdefaultfeatureslayer) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 10,
 *     },
 *   }"
 * >
 *   <y-map-default-features-layer />
 * </y-map>
 * ```
 */
class YMapDefaultFeaturesLayerDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * See the API entity documentation for detailed information. Supports ngOnChanges.
         * {@link https://yandex.ru/dev/jsapi30/doc/ru/ref/#YMapDefaultFeaturesLayerProps}
         */
        this.props = {};
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            this.layer = new ymaps3.YMapDefaultFeaturesLayer(this.props, this.options);
            map.addChild(this.layer);
            this.ready.emit({ ymaps3, entity: this.layer });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.layer) {
                this.layer.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.layer) {
            this.yMapComponent.map$.value?.removeChild(this.layer);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapDefaultFeaturesLayerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapDefaultFeaturesLayerDirective, isStandalone: true, selector: "y-map-default-features-layer", inputs: { props: "props", options: "options" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapDefaultFeaturesLayerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-default-features-layer',
                }]
        }], propDecorators: { props: [{
                type: Input
            }], options: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapDefaultSchemeLayer](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymapdefaultschemelayer) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 10,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 * </y-map>
 * ```
 */
class YMapDefaultSchemeLayerDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * See the API entity documentation for detailed information. Supports ngOnChanges.
         * {@link https://yandex.ru/dev/jsapi30/doc/ru/ref/#YMapDefaultSchemeLayerProps}
         */
        this.props = {};
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            this.layer = new ymaps3.YMapDefaultSchemeLayer(this.props, this.options);
            map.addChild(this.layer);
            this.ready.emit({ ymaps3, entity: this.layer });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.layer) {
                this.layer.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.layer) {
            this.yMapComponent.map$.value?.removeChild(this.layer);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapDefaultSchemeLayerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapDefaultSchemeLayerDirective, isStandalone: true, selector: "y-map-default-scheme-layer", inputs: { props: "props", options: "options" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapDefaultSchemeLayerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-default-scheme-layer',
                }]
        }], propDecorators: { props: [{
                type: Input
            }], options: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

/**
 * This component wraps the [ymaps3.YMapLayer](https://yandex.ru/dev/jsapi30/doc/ru/ref/#class-ymaplayer) class from the Yandex.Maps API.
 * All component inputs are named the same as the API class constructor arguments.
 *
 * ```html
 * <y-map
 *   [props]="{
 *     location: {
 *       center: [-0.127696, 51.507351],
 *       zoom: 10,
 *     },
 *   }"
 * >
 *   <y-map-default-scheme-layer />
 *
 *   <y-map-layer
 *     [props]="{
 *       type: 'markers',
 *       zIndex: 1800,
 *     }"
 *   />
 * </y-map>
 * ```
 */
class YMapLayerDirective {
    constructor() {
        this.ngZone = inject(NgZone);
        this.yMapComponent = inject(YMapComponent);
        this.destroy$ = new Subject();
        /**
         * The entity instance is created. This event runs outside an Angular zone.
         */
        this.ready = new EventEmitter();
    }
    ngOnInit() {
        this.yMapComponent.map$.pipe(filter(Boolean), takeUntil(this.destroy$)).subscribe((map) => {
            this.layer = new ymaps3.YMapLayer(this.props);
            map.addChild(this.layer);
            this.ready.emit({ ymaps3, entity: this.layer });
        });
    }
    ngOnChanges(changes) {
        // It must be run outside a zone; otherwise, all async events within this call will cause ticks.
        this.ngZone.runOutsideAngular(() => {
            if (this.layer) {
                this.layer.update(changes['props'].currentValue);
            }
        });
    }
    ngOnDestroy() {
        if (this.layer) {
            this.yMapComponent.map$.value?.removeChild(this.layer);
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapLayerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.6", type: YMapLayerDirective, isStandalone: true, selector: "y-map-layer", inputs: { props: "props" }, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.6", ngImport: i0, type: YMapLayerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'y-map-layer',
                }]
        }], propDecorators: { props: [{
                type: Input,
                args: [{ required: true }]
            }], ready: [{
                type: Output
            }] } });

/*
 * Public API Surface of angular-yandex-maps-v3
 */
// Components

/**
 * Generated bundle index. Do not edit.
 */

export { YApiLoaderService, YMapClustererDirective, YMapComponent, YMapControlButtonDirective, YMapControlCommonButtonDirective, YMapControlDirective, YMapControlsDirective, YMapDefaultFeaturesLayerDirective, YMapDefaultMarkerDirective, YMapDefaultSchemeLayerDirective, YMapFeatureDataSourceDirective, YMapFeatureDirective, YMapGeolocationControlDirective, YMapHintDirective, YMapLayerDirective, YMapListenerDirective, YMapMarkerDirective, YMapOpenMapsButtonDirective, YMapScaleControlDirective, YMapZoomControlDirective, Y_CONFIG, provideYConfig };
//# sourceMappingURL=angular-yandex-maps-v3.mjs.map
